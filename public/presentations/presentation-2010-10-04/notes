Hi, my name is Ivan and today I would like to talk about Testing the Responsive Layout.

For a long time engineers tried to automate testing of layout for their websites but it was a hard task. The most common solution for testing are manually or comparing screenshots, or combined when you have automated tool for gathering screenshots and later you check those yourself.

But what if we are dealing with responsive websites. We now have not only to test it in defferent desktop browsers but also have to check it for different screen sizes. And ideally we should be able to test it on real mobile devices.

What if we could describe the layout rules in simple words? and make it consistent across different screen sizes. What if we could test layout on real mobile devices?

Let me introduce you a new solution for this problem: Galen Framework. It is a framework for layout testing and functional testing of the websites. In this talk I will guide your through several topics:
- Writting page specifications for multiple screen sizes. An introduction to the core Galen language
- Parameterizing your test suite for different devices
- Dealing with the complex layout
- Running layout tests in a cloud to test in real mobile browsers
- Improve your test with visual check using partial image comparison
- Unleash the power of Javascript for your test and provide a nice structured reporting
- Add Galen to Continuous Integration and make it a solid part of your release cycle


So lets talk about Page Specifications or also so called Galen Specs.
The general syntax for page spec file is like this. These two lines filled with equals symbol are representing the area where you should define all your page objects. And this is how you do it. As simple as that a pair of object name and locator. Thats all you need. Well actually there is more stuff you can put in there but I am not going to go into such details in this talk.
As you can see there are 3 types of locators css, xpath and id. But being also a webdeveloper I prefer to use CSS locators and I use xpath on very rare cases
The next thing you do is a define a section with a tag. A little bit later I will explain a concept of sections and tags. And the most important part is the test objects with checks. You can list multiple checks under each test object and a check consists of two parts: a name and a text. Each check may have its own syntax but they all have similarities. And very important part: indentation is done using spaces. So no tabs.
So thats it. This is just to give you approximate picture on the syntax and now lets take a look at specific checks how galen framework verifies the layout.
So here is the one of the checks called Near. As you can see it allows you to verify that there is a specific distance between two objects and you can choose the orientation like left, right, top or bottom. And it reads almost natural: button is neat the textfield 10 pixels to the right
The next check on our list is inside. Galen allows you to verify that an object is located inside other object in a specific region like here: 10 pixel in the top left corner. Thats means that Galen will check that a button is completely inside a container and none of its edges stick out. And together with that it will verify that the margin for the button is 10 pixels. Also we can user multiple locations like here. As you can see here what we did is actually checked that margin on the left and right is the same. And also we did it with top and bottom. Which by the way also allows use to test that the button is centered horizontally and vertically inside container
As you see the language is far from the CSS language as it servers completely different purpose. It tries to be as close as possible to the natural language when you for instance need to explain another engineer how the page should look like. You don't care about all those css properties like: margin, padding, position, display and etc unless you are talking to another WEB engineer. Imagine that you have to explain your parents how the interface should look like. Where should the buttons be located and how it should behave. That language is exactly what galen tries to use. I am not saying it seccusseded in that as many people had different opinions but at least you see the direction.
So lets see more examples. Above and Below. Actually it is just an alias for the near spec but again we are trying to be more readable.
Aligned. Allows you to check that some specific edges of the selected objects are aligned. By the way notice the star symbol? That is a simple expression which allows us to match multiple objects in our page spec. It will search for all available object like menu-item-1, menu-item-2 and menu-item-3 and will copy the same check to all of them. In this example we check the gorizontall alignment only by top edge. We can also check bottom or both edges or we can even check that the objects are aligned by their center which is a rare case.
And here we check the verticall alignment by left edge. Also if you want to ingore 1 pixel misalginment you can add this error range. In here we state that if the alignment of objects is broken by one pixel we don't take it as an error. But if it is 2 pixels missalignment Galen will complain
So we don't have much time to go in details for all the available checks as this is a complete list and it is going to grow in future.
Now lets see how we can verify the pixels by using Ranges. Almost each check is using this pixels definition syntax and here is how it works. 
The exact value, is the most simple. If you expect to get a width of 100 pixels bu ton the website it is 99 pixel - Galen will complain
Now greater than and less than. 
A simple range. Reads nicely from 100 to 150 pixels
Aproximate value. It actually create a range out of the given value by adding 3 pixels left and right and in the end is transformed to 97 to 103px
Relative. In Galen you can define your value as the percentage of some other value. In this case we took a special object called screen and took 70% of this width
And all that we can combine like this

So that was the core of the Galen Specs Language. Now lets see it in the real example. I told you before that readability in Galen is very important. Imagine we have to make a page and we have a requirement. $READ_FROM_SLIDE$. Now lets try to write that down. This is how we can transform the requirement into Galen Specs. We have two sections: the first tagged as mobile and tablet, meaning that the rules in it apply for both devices. And the second section is only for desktop. Of course that is not engough to cover the complete layout test but it is just an example. 
Lets see how we can run it. This is simple command. You don't need a test suite in this case as we just want to open a browser and check its layout. Here we are doing it for mobile screen size.
In the end of the check galen will generate html report and this is how Galen complains. This is taken from other report just to show you how it displays the reports. It gives you the error message and highlights the object on the screenshot.
So it looks simple but what if want to build a proper test suite? This is how you do it. In a separate file you define a test suite which has a following syntax. A test name. A page url and browser window size. And a layout check.
Now lets go further. Lets say we want to run the same spec file for different browser sizes and aggregate all the tests in the same report. That is the way to do it.
Again the syntax is human readable. You can set variables, define tables with which later you can parameterize your tests. In this example we execute same test for same page but for 3 different contstrains: desktop, tablet and mobile.

Now what shall we do with complex layouts. In a real life we always have to deal with complex layout consiting of list objects and repeated components. So imagine we have this: user profiles search page which gives us a set of user profiles. Each user profile has a name picture .  This is how you deal with multiple objects. By simple putting a star symbol in the object declaration you talen Galen that this is not a name but a pattern for multiple objects. It will take the locator, find all the objects on page matching to this locator and will give you back a list of generated object names: user-profile-1, user-profile-2 and so on. Now lets check that each user profile appears above the next user profile like it was on our picture. First of all we write this: a range definition that starts with square breakets and tells Galen that next object and all of its check should be repeated multiple times. In this example we defined the range from 1 to 9 so it means that we will perform checks for nine user profiles. Also in this case we have to use special 'at' symbol which serves as a placeholder for the number from our range. And somehow we need to refer to next object in our check and you can do it by this simple operation in the curly brakets. We basically increment each parameter so in the end it will check that 1st user profile is above the 2nd and 2nd is above the third and so on. And also if you want to check the inner elements of each user profile like name, picture and others you can do a simple tricke. Define them in a separate spec file and refer to it as to component. But you can go even further with optimizing. Lets say you don't want to hardcode the amount of user profiles in your spec file. Then lets just use a count function like in here. So it tells to count all user profiles on page and parameterize from 2 to end. 

Now lets run our tests in a cloud. As Galen Framework is based on selenium you can run its tests in Selenium Grid. And that also allows you to run it in SauceLabs which gives you the oportunity to run it in real mobile browsers. SauceLabs has all major platforms mobile and desktop. Here is the screenshot from it. This is the problem of SauceLabs of the latets iOS version it gives you the screenshot of the device instead of the complete website page. Therefore because there is that iOS header Galen highlights the element with the offset. I hope SauceLabs will fix that anoying issue as it doesn't look nice in the presentation. But at least that's a proof that you can do layout test on a real mobile device.

So location and dimensions of elements is nice but what if we want to go even further and verify our page visually. For instance lets say we have a hover effect on the button that changes its background color. We can use color sheme check for that. For the default button we say that there should be approximately 2 percent of white color and more than 80 percent of blue. Galen takes a screenshot, calculates the color scheme and verifies the given colors if they match the color scheme.
But that does not allow you to test it pixel perfect. That is why there is also an image comparison technique which allows to take an image of a single object form page and verify it pixel to pixel with some predefined sample. Just define an image file and an error rate. Also you can specify the color tolerance whithin which pixels are considered to be equal. And here is the resulting report. Galen shows you the actual, expected image and the outcome of the comparing them which is called a comparison map
But what if we use fancy noise background in our page. And each time we chnage the size of the browser the background is displaced which results in a lot of noise pixels in our comparison map and makes our tests fail. Here is the solution: a filter system that allows you to remove noise from map before validating it. So even if you have a spelling error in the element. Noticed this "q" symbol instead of "o"? Galen will catch it. Of course it is not that easy but this algorythm gives you a lot of power and flexibility so you can make the image comparison really smart
